#============================================================================
# *  Mr.Mo's ABS
#============================================================================
# Mr.Mo "Muhammet Sivri"
# Version 1
# 09.16.06
# Thanks to Near Fantastica's methods;
# - In Range?, Get Range, In Direction?, enemy_dead?, treasure
# - RANGE_WEAPONS, RANGE_SKILLS
# - Class Game_Range(highly modified for convinience)
# - Scene_Skill(main, update_shk)
# - Dash and Sneak - Not modfied, except for Constants
# Most were modified by me to my style and to increase performance and 
# cleaner code.
#
# Give Credit to Near Fantastica as well, those methods saved me time and helped.
#
#============================================================================
# Intoduction
#============================================================================
# I wasnt happy with the current version of Near's ABS, and he wasn't going to
# update it anymore. So instead I made an ABS.
# Detailed Tutorial on the ABS and HUD modification tutorials added.
#============================================================================
# Explanation
#============================================================================
#--Skill Casting :
# If the skill is not ranged and its suppose to attack one enemy, it will attack
# the closest enemy.
# If the skill scope is more then 1 enemy, it can be ranged. It will just attack
# the enemies in that range.
# The skill animations can be assigned in the Constants section
# The default skill animation suffix is _cast. If you want a skill to have the 
# default animation(_casT) just don't do anything for it :)
#--Enemy AI :
# 0 = Dummy             - Will not attack but can be attacked
# 1 = See Range         - Will attack only if it can see an enemy
# 2 = Hear Range        - WIll attack only if it can hear an enemy
# 3 = Hear or See Range - Will attack if it can see or hear enemy
# 4 = Ally Under Attack - Will attack if its ally is under attack and if it can
#                                   see or hear the enemy
#
#--Enemy Explanation :
# Hate Points   - The enemy will randomly give out hate points to all of it's enemies.
#                 Later, it's enemies will be ordered from most to least hate points.
#
# Hate Groups   - The enemy will attack hate groups, meaning other enemies.
#                 The hate group enemies aren't considered allies. 
#                 The player's hate id is 0.
#                 Do not use the event ID, use the Monster ID, you can find it
#                 in the Database, Enemies Tab.
#
# Closest Enemy - The enemy will attack the closest enemy, if met the right AI
#                 conditions. Hate points are no longer needed, if this BOOLEAN
#                 is true.
#
# 
#--Comment List :
# To add a comment, click on the event command list, in the first tab, you should
# see the [ Comment... ] button. It should look similar to this.
#
# V = value
#
# Comment: ABS                 - Required for recognizing enemies.
# Comment: ID V                - Enemy ID from the database.
# Comment: Behavior V          - Refer to Enemy AI.
# Comment: Sight V             - See range the enemy can hear.
# Comment: Sound V             - Sound range the enemy can hear.
# Comment: ClosestEnemy V      - Refer to Enemy explantion
# Comment: HateGroup [V]       - Refer to Enemy explantion
# Comment: Aggressiveness V    - How fast will the enemy attack.
# Comment: Trigger V           - Refer to Triggers.
#
# Example:
#
# Comment: ABS
# Comment: ID 1
# Comment: Behavior 1
# Comment: Sight 5
# Comment: Sound 5
# Comment: ClosestEnemy true
# Comment: HateGroup [0]
# Comment: Aggressiveness 1 
# Comment: Trigger 0
#
#--Triggers :
# Trigger 0     - Will erase the event.
# Trigger 1 2   - Will turn on a switch with the ID of 2.
# Trigger 2 5 9 - Will change the Varaible's value with the ID of 5 to 9. If 9 is
#                 set to 0, the the Variable 5 will be added 1.
# Trigger 3 1   - Will change the local switch of the enemy to 1("A").
#                   1 = A
#                   2 = B
#                   3 = C
#                   4 = D
#
#--Startegy Usage :
# The ABS can be used to setup wars and make fights between NPCs. Imagination is
# the limit. 
# The events do not need to attack the player. Just remove the 0 from the hate
# group list.
#
# You can make an event a dummy, it can still be attacked, but it won't retaliate.
# This is usefull for practices, or teacing the player how to fight. It can also
# be used for NPC's.
#
# Make allias for the player. Remove the 0 from the hate group list and add all
# the monsters(their enemy IDs, database) on the map. The allias won't follow the player or anything
# but they would attack other monsters giving the effect of allince.
#
# Monster Pit Fights can also be made.
#
#--Default Animations
# charactername_melee  - melee attacks
# charactername_cast  - skills
#============================================================================
#--------------------------------------------------------------------------
# * SDK Log Script
#--------------------------------------------------------------------------
SDK.log("Mr.Mo's ABS", "Mr.Mo", 1, "09.16.06")
#--------------------------------------------------------------------------
# * Begin SDK Enable Test
#--------------------------------------------------------------------------
if SDK.state("Mr.Mo's ABS") == true
#--------------------------------------------------------------------------
# * Constants - MAKE YOUR EDITS HERE
#--------------------------------------------------------------------------
CAN_DASH = true  #Can the player Dash?
CAN_SNEAK = true #Can the player sneak?
#--------------------------------------------------------------------------
ATTACK_KEY = Input::Letters["S"]
#--------------------------------------------------------------------------
# Do not change the '=> 0', part.
# To Add more just make a new line; there are 10 examples :P
# Besides Numberkeys, you can use;
#  Input::Letters["LETTER"] Make sure the letter is in CAPS. 
#  Input::Numberpad[number]
#  Input::Fkeys[number]
#  For more keys look in to the Input Script
SKILL_KEYS = {
              Input::Letters["A"] => 0
              }
#--------------------------------------------------------------------------
SNEAK_KEY = Input::Letters["Z"]
DASH_KEY = Input::Letters["X"]
QUEST_KEY = Input::Fkeys[4]
#--------------------------------------------------------------------------
# You do not need to add the animation suffixes if you don't want the player
# to animate when attacking.
#--------------------------------------------------------------------------
#Ranged Weapons
RANGE_WEAPONS = {}
# RANGE_WEAPONS[Weapon_ID] = [Character Set Name, Move Speed, Animation, Range, Animation Suffix]
RANGE_WEAPONS[17] = ["Arrow", 9, 3, 35, 10]
RANGE_WEAPONS[18] = ["Arrow", 9, 3, 35, 10]
#--------------------------------------------------------------------------
#Ranged Weapons
RANGE_SKILLS = {}
# RANGE_SKILLS[Skill_ID] = [Range, Move Speed, Character Set Name]
RANGE_SKILLS[7] = [10, 5, "Fire_01"]
RANGE_SKILLS[8] = [10, 5, "Fire_02"]
RANGE_SKILLS[9] = [10, 5, "Default"]


#--------------------------------------------------------------------------
#Ranged Explosives
RANGE_EXPLODE = {}    # DISATTIVATO PERCHE' NON FUNZIONANTE
# RANGE_EXPLODE[Skill_ID] = [Range, Move Speed, Character Set Name, Explosive Range]
#--------------------------------------------------------------------------
#Skill Animations - Can also be used for Range_Explode
#I use _cast as an example, but it is not needed because by default every skill
#uses _cast. So if you are not using _cast for a skill add it here.
SKILL_ANIMATION = {}
 SKILL_ANIMATION[1...90] = ''
# SKILL_ANIMATION[Skill_ID] = Animation Suffix

#--------------------------------------------------------------------------
#Melee Animations - Don't touch here if the player is not going to animate when
#                   attacking.
#I use _melee as an example, but it is not needed because by default every attack
#uses _melee. So if you are not using _melee for an attack add it here.
MELEE_ANIMATION = {}
# MELEE_ANIMATION[Weapon_ID] = Animation Suffix
=begin
MELEE_ANIMATION[1] = "-Sword" 
MELEE_ANIMATION[2] = "-Sword"
MELEE_ANIMATION[3] = "-Sword"
MELEE_ANIMATION[4] = "-Sword"
MELEE_ANIMATION[5] = "-Spear"
MELEE_ANIMATION[6] = "-Spear"
MELEE_ANIMATION[7] = "-Spear"
MELEE_ANIMATION[8] = "-Spear"
MELEE_ANIMATION[9] = "-Axe"
MELEE_ANIMATION[10] = "-Axe"
MELEE_ANIMATION[11] = "-Axe"
MELEE_ANIMATION[12] = "-Axe" 
MELEE_ANIMATION[13] = "-Sword"
MELEE_ANIMATION[14] = "-Sword"
MELEE_ANIMATION[15] = "-Sword"
MELEE_ANIMATION[16] = "-Sword"
MELEE_ANIMATION[17] = "-Bow"
MELEE_ANIMATION[18] = "-Bow"
MELEE_ANIMATION[19] = "-Bow"
MELEE_ANIMATION[20] = "-Bow"
MELEE_ANIMATION[21] = "-Gun"
MELEE_ANIMATION[22] = "-Gun" 
MELEE_ANIMATION[23] = "-Gun"
MELEE_ANIMATION[24] = "-Gun"
MELEE_ANIMATION[25] = "-Mace"
MELEE_ANIMATION[26] = "-Mace"
MELEE_ANIMATION[27] = "-Mace"
MELEE_ANIMATION[28] = "-Mace"
MELEE_ANIMATION[29] = "-Rod"
MELEE_ANIMATION[30] = "-Rod"
MELEE_ANIMATION[31] = "-Rod"
MELEE_ANIMATION[32] = "-Rod"
MELEE_ANIMATION[33] = ""
MELEE_ANIMATION[34] = ""
MELEE_ANIMATION[35] = ""
MELEE_ANIMATION[36] = ""
MELEE_ANIMATION[37] = "-Bow"
MELEE_ANIMATION[38] = "-Bow"
MELEE_ANIMATION[39] = "-Bow"
MELEE_ANIMATION[40] = "-Bow"
=end
#--------------------------------------------------------------------------
#Game over once the player is dead?
GAME_OVER_DEAD = true
#--------------------------------------------------------------------------
#Mash Time
#Determines the cool down period between attacks of the player, 10 = 1 sec.
MASH_TIME = 10
#--------------------------------------------------------------------------
#Should it display damage?
DISPLAY_DAMAGE = true
#--------------------------------------------------------------------------
#Hotkey should say
HOTKEY_SAY = "Skill Assimilada!"
#--------------------------------------------------------------------------
#Terrain Tag
PASS_TAG = 1
#--------------------------------------------------------------------------
ANIMATE_PLAYER = true
ANIMATE_ENEMY = false
#--------------------------------------------------------------------------
DASH_SPEED = 12
SNEAK_SPEED = 2

dash_min=DASH_SPEED 
snake_min=SNEAK_SPEED

#--------------------------------------------------------------------------
# * Class Mo ABS - DO NOT EDIT BELOW, if you don't know what you are doing :)
#--------------------------------------------------------------------------
class MrMo_ABS
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_accessor :abs_active  #The ABS Active Boolean
  attr_accessor :enemies     #Enemy List
  attr_accessor :can_dash    #Player Dash Boolean
  attr_accessor :can_sneak   #Player Sneak Boolean
  attr_accessor :attack_key  #Attack Key
  attr_accessor :skill_keys  #Skill Keys
  attr_accessor :range
  attr_accessor :damage_display
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(con=true)
    #ABS Active Boolean
    @abs_active = con
    #ABS Enemy Variables
    @enemies = {}
    #Dash Imrmoo
    @can_dash = CAN_DASH 
    #Sneak Imrmoo
    @can_sneak = CAN_SNEAK
    #Attack Key
    @attack_key = ATTACK_KEY
    #Skill Keys
    @skill_keys = SKILL_KEYS
    #Quest Key
    @questlog_key = QUEST_KEY
    #Button Mash
    @button_mash = 0
    #Ranged Skills and Weapons
    @range = []
    #Display Demage true:false
    @damage_display = DISPLAY_DAMAGE
    #Game Over?
    @game_over = GAME_OVER_DEAD
    #Player Animated?
    @player_ani = ANIMATE_PLAYER
    #Enemy Animated?
    @enemy_ani = ANIMATE_ENEMY
    #Get Hate
    @get_hate = true
    # Dashing
    @dashing = false
    @dash_restore = false
    @dash_reduce= false
    @dash_timer = 0
    @dash_level = 5
    @dash_sec = 0
    @dash_speed = DASH_SPEED
    # Sneaking
    @sneaking = false
    @sneak_restore = false
    @sneak_reduce= false
    @sneak_timer = 0
    @sneak_level = 5
    @sneak_sec = 0
    @sneak_speed = SNEAK_SPEED
    
    
@dash_min=DASH_SPEED 
@snake_min=SNEAK_SPEED

  end
  #--------------------------------------------------------------------------
  # * Range Weapons
  #--------------------------------------------------------------------------
  def RANGE_WEAPONS
    return RANGE_WEAPONS
  end
  #--------------------------------------------------------------------------
  # * Range Skills
  #--------------------------------------------------------------------------
  def RANGE_SKILLS
    return RANGE_SKILLS
  end
  #--------------------------------------------------------------------------
  # * Range Explode
  #--------------------------------------------------------------------------
  def RANGE_EXPLODE
    return RANGE_EXPLODE
  end
  #--------------------------------------------------------------------------
  # * Hotkey
  #--------------------------------------------------------------------------
  def HOTKEY_SAY
    return HOTKEY_SAY
  end
  #--------------------------------------------------------------------------
  # * Pass Tag
  #--------------------------------------------------------------------------
  def PASS_TAG
    return PASS_TAG
  end
  #--------------------------------------------------------------------------
  # * ABS Refresh(Event, List, Characterset Name
  #--------------------------------------------------------------------------
  def refresh(event, list, character_name)
    @get_hate = true
    #Delete the event from the list
    @enemies.delete(event.id)
    #Skip the event if its invisible or doesn't contain a list
    return if character_name == "" or list == nil
    #Get the parameters
    parameters = SDK.event_comment_input(event, 10, "ABS")
    #Skip if the paramete is NIL
    return if parameters.nil?
    #Get Enemy ID
    id = parameters[0].split
    #Get Enemy
    enemy = $data_enemies[id[1].to_i]
    #Skip If Enemy is NIL
    return if enemy == nil
    @enemies[event.id] = ABS_Enemy.new(enemy.id)
    #Set Event ID
    @enemies[event.id].event_id = event.id
    #Get Event 
    @enemies[event.id].event = event
    #Set Behavior
    behavior = parameters[1].split
    @enemies[event.id].behavior = behavior[1].to_i
    #Set See Range
    see_range = parameters[2].split
    @enemies[event.id].see_range = see_range[1].to_i
    #Set Hear Range
    hear_range = parameters[3].split
    @enemies[event.id].hear_range = hear_range[1].to_i
    #Set Closest Enemy Boolean
    closest_enemy = parameters[4].split
    @enemies[event.id].closest_enemy = eval(closest_enemy[1])
    #Set Hate Group
    hate_group = parameters[5].split
    @enemies[event.id].hate_group = eval(hate_group[1])    
    #Set Aggresiveness
    aggressiveness = parameters[6].split
    @enemies[event.id].aggressiveness = aggressiveness[1].to_i
    #Set Speed
    speed = parameters[7].split
    @enemies[event.id].temp_speed = speed[1].to_i
    #Set Frequency
    freq = parameters[8].split
    @enemies[event.id].temp_frequency = freq[1].to_i
    #Set Trigger
    trigger = parameters[9].split
    @enemies[event.id].trigger= [trigger[1].to_i, trigger[2].to_i, trigger[3].to_i]
  end
  #--------------------------------------------------------------------------
  # * Make Hate Points(Enemy)
  #--------------------------------------------------------------------------
  def make_hate_points(e)

    #Get all the enemies of the enemy
    e.hate_points[$game_player.event_id] = rand(999)
    for id in e.hate_group
      #See if the ID in the Hate group is in the enemy ID 
      for enemy in @enemies.values
        #Skip NIL values
        next if enemy == nil
        if enemy.enemy_id == id
          #Insert in to the list if the enemy is in hate group
          e.hate_points[enemy.event_id] = rand(999)
        end
      end
    end
    
    
  end
  #--------------------------------------------------------------------------
  # * Update(Frame)
  #--------------------------------------------------------------------------
  def update
    return if !@abs_active
    #Update Player
    update_player
    #Update Enemy AI
    update_enemy if @enemies != {}
    #Update Dash
    update_dash if @can_dash
    #Update Sneak
    update_sneak if @can_sneak
    #Update Ranged
    for range in @range
      next if range == nil
      range.update
    end
  end
  #--------------------------------------------------------------------------
  # * Update Enemy AI(Frame)
  #--------------------------------------------------------------------------
  def update_enemy
    #Get all the enemies on the list
    for enemy in @enemies.values
      #Skip NIL values
      next if enemy == nil or enemy.dead?
      #Skip if not on screen
      next if !in_screen?(enemy.event)
      #Make Hate Points
      make_hate_points(enemy) if @get_hate
      if enemy.in_battle == false
        #Get the enemy behavior
        b =  enemy.behavior
        next if b == 0 # Dummy
        #Next enemy if this enemy can't see the player
        next if b == 1 and !can_enemy_see(enemy)
        #Next enemy if this enemy can't hear the player
        next if b == 2 and !can_enemy_hear(enemy)
        #Next enemy if this enemy can't see or hear the player
        next if b == 3 and !can_enemy_see(enemy) and !can_enemy_hear(enemy)
        #Next if its not
        next if b == 4 and !enemy_ally_in_battle?(enemy)
        #Next enemy if this enemy can't see or hear the player
        next if b == 5 and !can_enemy_see(enemy) and !can_enemy_hear(enemy) and !enemy_ally_in_battle?(enemy)
      else
        next if enemy.behavior == 0
        #If the enemy can't see it's enemy, skip the enemy
        if !in_range?(enemy.event, enemy.attacking.event, enemy.see_range) and
           !in_range?(enemy.event, enemy.attacking.event, enemy.hear_range)
          #Restore movement
          restore_movement(enemy)
          #Take it out off battle
          enemy.in_battle = false
          enemy.attacking = nil
          next
        end
        #Update the enemy attack or follow
        update_enemy_attack(enemy,enemy.attacking)
        #Skip this if the attack killed the enemy
        next if enemy == nil or enemy.attacking == nil
        enemy.event.move_to(enemy.attacking.event) if !in_range?(enemy.event, enemy.attacking.event, 1) and !enemy.event.moving?
        enemy.event.turn_to(enemy.attacking.event) if !in_direction?(enemy.event, enemy.attacking.event) and in_range?(enemy.event, enemy.attacking.event, 1)
      end
    end
    @get_hate = false
  end
  #--------------------------------------------------------------------------
  # * Update Enemy Attack(Enemy)
  #--------------------------------------------------------------------------
  def update_enemy_attack(e,actor)
    #Return if the enemy can't attack
    return if e.actions == nil or e.actions == []
    #Get all actions
    for action in e.actions
      #Next if enemy can't attack
      next if enemy_pre_attack(e, action)
      #Get the current action kind
      case action.kind
      when 0 # Basic
       next if Graphics.frame_count % (e.aggressiveness * 30) != 0
       #Get the action
       case action.basic
       when 0 #Attack
         next if !in_range?(e.event, actor.event, 1) or !in_direction?(e.event, actor.event)
         #Attack it's enemy
         a = actor if actor.is_a?(ABS_Enemy)
         a = $game_party.actors[0] if !actor.is_a?(ABS_Enemy)
         a.attack_effect(e)
         #Animate the player
         animate(e.event, e.event.character_name+"_melee") if @enemy_ani
         #Show Animation
         hit_enemy(actor,e) if a.damage != "Miss" and a.damage != 0
         #Check if enemy's enemy is dead
         enemy_dead?(a,e)
         #Make enemy
         if a.is_a?(ABS_Enemy)
           #Set the new target for the enemy
           a.attacking = e
           #The enemy is now in battle
           a.in_battle = true
         end
       when 1..3 #Nothing
         return
       end
      when 1..2 #Skill
        #Get the skill
        skill = $data_skills[action.skill_id]
        #Return if the skill is NIL
        return if skill == nil
        #Get the skill scope
        case skill.scope
        when 1 # One Enemy
          return if Graphics.frame_count % (e.aggressiveness * 30) != 0
          next if !in_direction?(e.event, actor.event)
          next if !e.can_use_skill?(skill)
          #Animate the enemy
          animate(e.event, e.event.character_name+"_skill") if @enemy_ani
          if RANGE_SKILLS.has_key?(skill.id)
            @range.push(Game_Ranged_Skill.new(e.event, e, skill))
            e.sp -= skill.sp_cost
            return
          end
          #If the skill is not ranged
          enemies = []
          #Get all enemies    
          for enemy in @enemies.values
            next if enemy == nil
            next if !e.hate_group.include?(enemy.enemy_id)
            enemies.push(enemy)
          end
          enemies.push($game_player)
          #Order them from closest to the farthest
          enemies.sort! {|a,b|
          get_range(a.event,b.event) - get_range(b.event,a.event) }
          #Attack the closest one
          enemies[0].actor.effect_skill(e, skill)
          #Take off SP
          e.sp -= skill.sp_cost
          #Show Animetion on enemy
          hit_enemy(enemies[0], e, skill.animation2_id) if enemies[0].actor.damage != "Miss" and enemies[0].actor.damage != 0
          #Return if enemy is dead 
          return if enemy_dead?(enemies[0].actor,e)
          return if enemies[0].is_a?(Game_Player)
          #If its alive, put it in battle
          enemies[0].in_battle = true
          #Make it attack the player
          enemies[0].attacking = e
          #Setup movement
          setup_movement(e)
          return
        when 3..4, 7 # User   
          return if Graphics.frame_count % (e.aggressiveness * 100) != 0
          next if e.hp > skill.power.abs
          #Animate the player
          animate(e.event, e.event.character_name+"_skill") if @enemy_ani
          e.effect_skill(e, skill)
          e.sp -= skill.sp_cost
          e.event.animation_id = skill.animation2_id
        end
        return
      end
    end
  end
  #--------------------------------------------------------------------------
  # * Update Player
  #--------------------------------------------------------------------------
  def update_player
    @actor = $game_party.actors[0]
    #Update click time
    @button_mash -= 1 if @button_mash > 0
    return if @button_mash > 0
    #Check Ranged attack
    if Input.trigger?(@attack_key)
      @button_mash = MASH_TIME
      case @actor.weapon_id
      when 21
        Audio.se_play("Audio/SE/102-Attack14")
      when 22
        Audio.se_play("Audio/SE/102-Attack14")
      when 23
        Audio.se_play("Audio/SE/102-Attack14")
      when 24
        Audio.se_play("Audio/SE/102-Attack14")
      end
      return player_range if RANGE_WEAPONS.has_key?(@actor.weapon_id)
      return player_melee
    end
    
    if Input.trigger?(@questlog_key)
      $scene=Scene_Quest.new
    end
    
    #Check for Skill attacks
    for key in @skill_keys.keys
      next if @skill_keys[key] == nil or @skill_keys[key] == 0
      next if !Input.trigger?(key)
      @button_mash = MASH_TIME
      id = @skill_keys[key]
      if RANGE_EXPLODE.has_key?(id)
        player_explode(id) if Input.trigger?(key)
      else
        player_skill(id) if Input.trigger?(key)
      end
    end
    return
  end
  #--------------------------------------------------------------------------
  # * Player Ranged Attack
  #--------------------------------------------------------------------------
  def player_range
    #Get the weapon
    w = RANGE_WEAPONS[@actor.weapon_id]
    #Return if the ammo isn't there
    return if $game_party.item_number(w[3]) == 0
    #Delete an ammo
    $game_party.lose_item(w[3], 1)
    #Make the attack
    @range.push(Game_Ranged_Weapon.new($game_player, @actor, @actor.weapon_id))
    @online_chara = w[0]
    @online_move_speed = w[1]
    @online_range = w[4]
    Network::Main.socket.send("<10b>self.range_sprite(#{$game_map.map_id},[#{$game_player.direction},#{$game_player.x},#{$game_player.y}],$game_party.actors[0],#{@actor.weapon_id},'#{@online_chara}',#{@online_move_speed},#{@online_range})</10b>\n")
    animate($game_player, $game_player.character_name)
    #Animate
    return if w[5] == nil
    animate($game_player, $game_player.character_name) if @player_ani
    return
  end
  #--------------------------------------------------------------------------
  # * Player Melee Attack
  #--------------------------------------------------------------------------
  def player_melee
    return if $data_weapons[@actor.weapon_id] == nil
    
      #Get Animation
      a = $data_weapons[@actor.weapon_id].animation2_id
      #Animate the player
      if MELEE_ANIMATION[@actor.weapon_id] == nil
        #animate($game_player, $game_player.character_name+"_melee") if @player_ani
        animate($game_player, $game_player.character_name) if @player_ani
      else
        m = MELEE_ANIMATION[@actor.weapon_id]
        animate($game_player,  $game_player.character_name+"-atk") if @player_ani
      end
      
      
    #Get all enemies
    for e in @enemies.values
      #Skip NIL values or dead enemies
      next if e == nil or e.dead?
      #Skip the enemy if its not close by or not facing
      next if !in_direction?($game_player, e.event) or !in_range?($game_player, e.event, 1)
      #Attack the enemy
      e.attack_effect(@actor)
      #Get Animation
    #  a = $data_weapons[@actor.weapon_id].animation2_id
      #Hit enemy if the attack succeeds
      hit_enemy(e, @actor, a) if e.damage != "Miss" and e.damage != 0
      #Animate the player
    #  if MELEE_ANIMATION[@actor.weapon_id] == nil
        #animate($game_player, $game_player.character_name+"_melee") if @player_ani
     #   animate($game_player, $game_player.character_name) if @player_ani
     # else
     #   m = MELEE_ANIMATION[@actor.weapon_id]
     #   animate($game_player,  $game_player.character_name+"-atk") if @player_ani
     # end
      #Return if the enemy is dead
      return if enemy_dead?(e,@actor)
      return if !e.hate_group.include?(0)
      #Set the new target for the enemy
      e.attacking = $game_player
      #The enemy is now in battle
      e.in_battle = true
      #Setup movement
      setup_movement(e)
    end
  end
  #--------------------------------------------------------------------------
  # * Player Skill Attack
  #--------------------------------------------------------------------------
  def player_skill(id)
    #Get Skill
    skill = $data_skills[id]
    #Return if the skill doesn't exist
    return if skill == nil
    #Return if the actor doesn't have the skill
    return if !@actor.skills.include?(skill.id)
    #Return if the actor can't use the skill
    return if !@actor.can_use_skill?(skill)
    #Animate
    if SKILL_ANIMATION.has_key?(id)
      l = SKILL_ANIMATION[id]
      animate($game_player, $game_player.character_name+"-cast") if @player_ani
    else
      animate($game_player, $game_player.character_name) if @player_ani
    end
    #Get the skill scope
    case skill.scope
    when 1 #Enemy
      #If the skill is ranged
      if RANGE_SKILLS.has_key?(skill.id)
        #Add to range
        @range.push(Game_Ranged_Skill.new($game_player, @actor, skill))
              
        @o = RANGE_SKILLS[skill.id]
        @online_chara = @o[2]
        @online_move_speed = @o[1]
        @online_range = @o[0]
        Network::Main.socket.send("<10b>self.range_sprite(#{$game_map.map_id},[#{$game_player.direction},#{$game_player.x},#{$game_player.y}],$game_party.actors[0],#{@actor.weapon_id},'#{@online_chara}',#{@online_move_speed},#{@online_range})</10b>\n")

        #Take off SP
        @actor.sp -= skill.sp_cost
        return
      end
      #If the skill is not ranged
      enemies = []
      #Get all enemies
      for enemy in @enemies.values
        next if enemy == nil
        enemies.push(enemy)
      end
      #Order them from closest to the farthest
      enemies.sort! {|a,b|
      get_range(a.event,b.event) - get_range(b.event,a.event) }
      #Attack the closest one
      enemies[0].effect_skill(@actor, skill)
      #Take off SP
      @actor.sp -= skill.sp_cost
      #Show Animetion on enemy
      hit_enemy(enemies[0], @actor, skill.animation2_id) if enemies[0].damage != "Miss" and enemies[0].damage != 0
      #Return if enemy is dead 
      return if enemy_dead?(enemies[0],@actor)
      return if !enemy.hate_group.include?(0)
      #If its alive, put it in battle
      enemies[0].in_battle = true
      #Make it attack the player
      enemies[0].attacking = $game_player
      #Setup movement
      setup_movement(enemies[0])
      return
    when 2 #All Emenies
      #Play the animation on player
      $game_player.animation_id = skill.animation2_id
      #Take off SP
      @actor.sp -= skill.sp_cost
      #If the skill is ranged
      if RANGE_SKILLS.has_key?(skill.id)
        enemies = get_all_range
      else
        enemies = @enemies
      end
      #Get all enemies
      for e in enemies.values
        #Skip NIL values
        next if e== nil
        #Attack enemy
        e.effect_skill(@actor, skill)
        #Show Animetion on enemy
        hit_enemy(e, @actor, 0) if enemy.damage != "Miss" and enemy.damage != 0
        #Skip this enemy if its dead 
        next if enemy_dead?(e,@actor)
        next if !e.hate_group.include?(0)
        #If its alive, put it in battle
        enemy.in_battle = true
        #Make it attack the player
        enemy.attacking = $game_player
        #Setup movement
        setup_movement(e)
      end
      return
    when 3..4, 7 #User
      #Use the skill on the player
      actor.effect_skill(@actor, skill)
      #Take off SP
      @actor.sp -= skill.sp_cost
      #Play animation
      $game_player.animation_id = skill.animation2_id
      return
    end
  end
  #--------------------------------------------------------------------------
  # * Player Explode Attack
  #--------------------------------------------------------------------------
  def player_explode(id)
    #Get Skill
    skill = $data_skills[id]
    #Return if the skill doesn't exist
    return if skill == nil
    #Return if the actor doesn't have the skill
    return if !@actor.skills.include?(skill.id)
    #Return if the actor can't use the skill
    return if !@actor.can_use_skill?(skill)
    #Animate
    if SKILL_ANIMATION.has_key?(id)
      l = SKILL_ANIMATION[id]
      animate($game_player, $game_player.character_name+l.to_s) if @player_ani
    else
      animate($game_player, $game_player.character_name) if @player_ani
    end
    #Add to range
    @range.push(Game_Ranged_Explode.new($game_player, @actor, skill))
    #Take off SP
    @actor.sp -= skill.sp_cost
    return
  end
  #--------------------------------------------------------------------------
  # * Enemy Dead?(Enemy) or (Player)
  #--------------------------------------------------------------------------
  def enemy_dead?(e,a)
    #Return a new method if e is an actor
    return player_dead?(e,a) if e.is_a?(Game_Actor)
    #Return false if enemy dead
    return false if !e.dead?
    enemy = e
    
    treasure(enemy) if a.is_a?(Game_Actor)
    a.attacking = nil if !a.is_a?(Game_Actor)
    a.in_battle = false if !a.is_a?(Game_Actor)
    id = enemy.event_id
    
         
    #Remove from list
    @enemies.delete(id)
    event = enemy.event
   # event.character_name = ""
    case enemy.trigger[0]
    when 0
      @map = $game_map.map_id
      Network::Main.socket.send("<event_kill>uccidi_event(#{@map},#{id})</event_kill>\n")
   when 1
      print "EVENT " + event.id.to_s + "Trigger Not Set Right ~!" if enemy.trigger[1] == 0
      $game_switches[enemy.trigger[1]] = true
      $game_map.need_refresh = true
    when 2
      print "EVENT " + event.id.to_s + "Trigger Not Set Right ~!" if enemy.trigger[1] == 0
      if enemy.trigger[2] == 0
        $game_variables[enemy.trigger[1]] += 1
        $game_map.need_refresh = true
      else
        $game_variables[enemy.trigger[1]] = enemy.trigger[2]
        $game_map.need_refresh = true
      end
    when 3  
      value = "A" if enemy.trigger[1] == 1
      value = "B" if enemy.trigger[1] == 2
      value = "C" if enemy.trigger[1] == 3
      value = "D" if enemy.trigger[1] == 4
      print "EVENT " + event.id.to_s + "Trigger Not Set Right ~!" if value == 0
      key = [$game_map.map_id, event.id, value]
      $game_self_switches[key] = true
      $game_map.need_refresh = true
    end
    #Return true if the e is dead
    return true
  end
  #--------------------------------------------------------------------------
  # * Player Dead(Player,Enemy)
  #--------------------------------------------------------------------------
  def player_dead?(a,e)
    #return if the player is not dead
    return false if !a.dead?
    #If the player is dead;
    e.in_battle = false if e != nil and !e.is_a?(Game_Actor)
    e.attacking = nil if e != nil and !e.is_a?(Game_Actor)
    #Game Over?
    $game_temp.gameover = true if @game_over
    return true
  end
  #--------------------------------------------------------------------------
  # * Treasure(Enemy)
  #--------------------------------------------------------------------------
  def treasure(enemy)
    exp = 0
    gold = 0
    treasures = []
    unless enemy.hidden
      exp += enemy.exp
      gold += enemy.gold
      if rand(100) < enemy.treasure_prob
        if enemy.item_id > 0
          treasures.push($data_items[enemy.item_id])
        end
        if enemy.weapon_id > 0
          treasures.push($data_weapons[enemy.weapon_id])
        end
        if enemy.armor_id > 0
          treasures.push($data_armors[enemy.armor_id])
        end
      end
    end
    treasures = treasures[0..5]
    for i in 0...$game_party.actors.size
      actor = $game_party.actors[i]
      if actor.cant_get_exp? == false
      last_level = actor.level
        actor.exp += exp
        Network::Main.socket.send("<10b>party_exp('#{actor.name}',#{exp})</10b>\n")
        if actor.level > last_level
          actor.hp = actor.maxhp
          actor.sp = actor.maxsp
          $game_player.animation_id = 1
        end
      end
    end
    $game_party.gain_gold(gold)
    for item in treasures
      case item
      when RPG::Item
        $game_party.gain_item(item.id, 1)
       when RPG::Weapon
        $game_party.gain_weapon(item.id, 1)
      when RPG::Armor
        $game_party.gain_armor(item.id, 1)
      end
    end
  end
  #--------------------------------------------------------------------------
  # * Hit Enemy(Enemy) or (Player)
  #--------------------------------------------------------------------------
  def hit_enemy(e,a,animation=nil)
    @random_animation= rand(10)
    case @random_animation
    when 0..3
    e.event.jump(0, 0)
    when 4..7
    e.event.move_backward
    when 8..10
    e.event.jump(0, 0)
    e.event.move_backward
  end
    return if animation == 0
    if animation == nil
      e.event.animation_id = a.animation2_id
    else
      e.event.animation_id = animation
    end
  end
  #--------------------------------------------------------------------------
  # * Enemy Pre-Attack(Enemy,Actions) - Checks action conditions to see if the 
  #   enemy can attack.
  #--------------------------------------------------------------------------
  def enemy_pre_attack(enemy, actions)
    return true if enemy.hp * 100.0 / enemy.maxhp > actions.condition_hp
    return true if $game_party.max_level < actions.condition_level
    switch_id = actions.condition_switch_id
    return true if actions.condition_switch_id > 0 and $game_switches[switch_id] == false
    n = rand(11) 
    return true if actions.rating < n
    return false
  end
  #--------------------------------------------------------------------------
  # * Can Enemy See(Enemy)
  #--------------------------------------------------------------------------
  def can_enemy_see(e)
    #Get all enemies of the enemy
    enemies = []
    enemies.push($game_player) if e.hate_group.include?(0)
    #Get the hate enemies
    for enemy in @enemies.values
      next if enemy == nil
      next if enemy == e
      if e.hate_group.include?(enemy.enemy_id)
        #Insert in to the list if the enemy is in hate group
        enemies.push(enemy)
      end
    end
    #Order the enemies
    if !e.closest_enemy
      #Order from hate points
      enemies.sort! {|a,b|
      e.hate_points[b.event_id] - e.hate_points[a.event_id] }
    else
      enemies.sort! {|a,b|
      get_range(e.event,b.event) - get_range(e.event,a.event) }
    end
    #Start loop to see if any enemy is seeable
    for enemy in enemies
      #Skip NIL value
      next if enemy == nil
      #Skip if not in range
      next if !in_range?(e.event, enemy.event, e.see_range)
      #Skip if not looking
      next if !in_direction?(e.event, enemy.event)
      #Add to enemy attack list
      e.attacking = enemy
      #Enemy is now in battle
      e.in_battle = true
      #Setup the movement
      setup_movement(e)
      #Return true
      return true
    end
    #Return False
    return false
  end
  #--------------------------------------------------------------------------
  # * Setup the Movement Type to 0(Enemy)
  #--------------------------------------------------------------------------
  def setup_movement(e)
    #Set Speed
    e.event.move_speed = e.temp_speed
    #Set Frequency
    e.event.move_frequency = e.temp_frequency
    #Set Move Type
    e.temp_move_type = e.event.move_type
    e.event.move_type = 0
  end
  #--------------------------------------------------------------------------
  # * Restore the Movement Type(Enemy)
  #--------------------------------------------------------------------------
  def restore_movement(e)
    #Restore Speed
    e.temp_speed = e.event.move_speed
    #Restore Frequency
    e.temp_frequency = e.event.move_frequency
    #Restore Move Type
    e.event.move_type = e.temp_move_type
    e.temp_move_type = 0
  end
  #--------------------------------------------------------------------------
  # * Can Enemy Hear(Enemy)
  #--------------------------------------------------------------------------
  def can_enemy_hear(e)
    #Get all enemies of the enemy
    enemies = []
    enemies.push($game_player) if e.hate_group.include?(0)
    #Get the hate enemies
    for enemy in @enemies.values
      next if enemy == nil
      next if enemy == e
      if e.hate_group.include?(enemy.enemy_id)
        #Insert in to the list if the enemy is in hate group
        enemies.push(enemy)
      end
    end
    #Order the enemies
    if !e.closest_enemy
      #Order from hate points
      enemies.sort! {|a,b|
      e.hate_points[b.event_id] - e.hate_points[a.event_id] }
    else
      enemies.sort! {|a,b|
      get_range(e.event,b.event) - get_range(e.event,a.event) }
    end
    #Start loop to see if any enemy is seeable
    for enemy in enemies
      #Skip NIL value
      next if enemy == nil
      #Skip if Sneaking
      next if @sneaking
      #Skip if not in range
      d = 0
      d = DASH_SPEED if @dashing
      next if !in_range?(e.event, enemy.event, e.hear_range+d)
      #Add to enemy attack list
      e.attacking = enemy
      #Enemy is now in battle
      e.in_battle = true
      #Setup the movement
      setup_movement(e)
      #Return true
      return true
    end
    #Return False
    return false
  end
  #--------------------------------------------------------------------------
  # * Enemy Ally in_battle?(Enemy)
  #--------------------------------------------------------------------------
  def enemy_ally_in_battle?(enemy)
    #Start list
    allies = []
    #Get all allies
    for ally in @enemies.values
      #Skip NIL Value
      next if ally == nil
      #Skip if value is in hate group
      next if enemy.hate_group.include?(ally.enemy_id)
      #Skip if the ally is not in_battle
      next if !ally.in_battle
      #Skip if the enemy can't see ally
      next if !in_range?(enemy.event, ally.event, enemy.see_range)
      #Skip if the enemy can't hear ally
      next if !in_range?(enemy.event, ally.event, enemy.hear_range)
      #Add to enemy attack list
      enemy.attacking = ally.attacking
      #Enemy is now in battle
      enemy.in_battle = true
      #Setup the movement
      setup_movement(enemy)
      #Return True
      return true
    end
    #Return False
    return false
  end
  #--------------------------------------------------------------------------
  # * Update Dash
  #--------------------------------------------------------------------------
  def update_dash
    if Input.pressed?(DASH_KEY)
      if $game_player.moving?
        @dashing = true
        $game_player.move_speed = DASH_SPEED
        @dash_restore = false
        if @dash_reduce == false
          @dash_timer = 50 # Initial time off set
          @dash_reduce = true
        else
          @dash_timer-= 1
        end
        @dash_sec = (@dash_timer / Graphics.frame_rate)%60
        if @dash_sec == 0
          if @dash_level != 0
            @dash_level -= 1
            @dash_timer = 50 # Timer Count
          end
        end
        if @dash_level == 0
          @dashing = false
          $game_player.move_speed = 4
        end
      end
    else
      @dashing = false
      $game_player.move_speed = 4
      @dash_reduce = false
      if @dash_restore == false
        @dash_timer = 80 # Initial time off set
        @dash_restore = true
      else
        @dash_timer-= 1
      end
      @dash_sec = (@dash_timer / Graphics.frame_rate)%60
      if @dash_sec == 0
        if @dash_level != 5
          @dash_level+= 1
          @dash_timer = 60
        end
      end
    end
  end
  #--------------------------------------------------------------------------
  # * Update Sneak
  #--------------------------------------------------------------------------
  def update_sneak
    if Input.pressed?(SNEAK_KEY)
      if $game_player.moving?
        @sneaking = true
        $game_player.move_speed = SNEAK_SPEED
        @sneak_restore = false
        if @sneak_reduce == false
          @sneak_timer = 50 # Initial time off set
          @sneak_reduce = true
        else
          @sneak_timer-= 1
        end
        @sneak_sec = (@sneak_timer / Graphics.frame_rate)%60
        if @sneak_sec == 0
          if @sneak_level != 0
            @sneak_level -= 1
            @sneak_timer = 100 # Timer Count
          end
        end
        if @sneak_level == 0
          @sneaking = false
          $game_player.move_speed = 4
        end
      end
    else
      @sneaking = false
      $game_player.move_speed = 4
      @sneak_reduce = false
      if @sneak_restore == false
        @sneak_timer = 80 # Initial time off set
        @sneak_restore = true
      else
        @sneak_timer-= 1
      end
      @sneak_sec = (@sneak_timer / Graphics.frame_rate)%60
      if @sneak_sec == 0
        if @sneak_level != 5
          @sneak_level+= 1
          @sneak_timer = 60 # Timer Count
        end
      end
    end
  end
  #--------------------------------------------------------------------------
  # * Get Range(Element, Object) - Near Fantastica
  #--------------------------------------------------------------------------
  def get_range(element, object)
    x = (element.x - object.x) * (element.x - object.x)
    y = (element.y - object.y) * (element.y - object.y)
    r = x + y
    r = Math.sqrt(r)
    return r.to_i
  end
  #--------------------------------------------------------------------------
  # * Checks the object range
  #--------------------------------------------------------------------------
  def in_screen?(object)
    screne_x = $game_map.display_x 
    screne_x -= 256
    screne_y = $game_map.display_y
    screne_y -= 256
    screne_width = $game_map.display_x 
    screne_width += 2816
    screne_height = $game_map.display_y
    screne_height += 2176
    return false if object.real_x <= screne_x
    return false if object.real_x >= screne_width
    return false if object.real_y <= screne_y
    return false if object.real_y >= screne_height
    return true
  end
  #--------------------------------------------------------------------------
  # * In Range?(Element, Object, Range) - Near Fantastica
  #--------------------------------------------------------------------------
  def in_range?(element, object, range)
    x = (element.x - object.x) * (element.x - object.x)
    y = (element.y - object.y) * (element.y - object.y)
    r = x + y
    return true if r <= (range * range)
    return false
  end
  #--------------------------------------------------------------------------
  # * Get ALL Range(Element, Range)
  #--------------------------------------------------------------------------
  def get_all_range(element, range)
    objects = []
    for e in @enemies.values
      objects.push(e) if in_range?(element, e.event, range)
    end
    return objects
  end
  #--------------------------------------------------------------------------
  # * In Direction?(Element, Object) - Near Fantastica
  #--------------------------------------------------------------------------
  def in_direction?(element, object)
    return true if element.direction == 2 and object.y >= element.y and object.x == element.x
    return true if element.direction == 4 and object.x <= element.x and object.y == element.y
    return true if element.direction == 6 and object.x >= element.x and object.y == element.y
    return true if element.direction == 8 and object.y <= element.y and object.x == element.x
    return false
  end
  #--------------------------------------------------------------------------
  # * Animate(object, name)
  #--------------------------------------------------------------------------
  def animate(object, name)
    object.set_animate(name)
  end
#--------------------------------------------------------------------------
# * End of class
#--------------------------------------------------------------------------
end
#============================================================================
# *  Range Base
#============================================================================
class Range_Base < Game_Character
  attr_accessor :range
  attr_accessor :draw
  attr_accessor :stop
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(parent, actor, attack)
    @step = 0
    @parent = parent
    @actor = actor
    @draw = true
    @stop  = false
    @range = 0
    @explosive = false
    @showing_ani = false
    super()
    if @parent.is_a?(Array)
    @move_direction = @parent[0]
    moveto(@parent[1],@parent[2])
    else
    @move_direction = @parent.direction
    moveto(@parent.x, @parent.y)
    end
  
  end
  #--------------------------------------------------------------------------
  # * Refresh
  #--------------------------------------------------------------------------
  def refresh
    @character_name = @range_wepaon[0]
    @move_speed = @range_wepaon[1]
    @range = @range_wepaon[4]
  end
  #--------------------------------------------------------------------------
  # * Force Movement
  #--------------------------------------------------------------------------
  def froce_movement
    m = @move_direction
    @y += 1 if m == 2
    @x -= 1 if m == 4
    @x += 1 if m == 6
    @y -= 1 if m == 8
  end
  #--------------------------------------------------------------------------
  # * Update
  #-------------------------------------------------------------------------
  def update
    super
    return if @explosive
    #Return if moving
    return if moving?
    # Get new coordinates
    d = @move_direction
    new_x = x + (d == 6 ? 1 : d == 4 ? -1 : 0)
    new_y = y + (d == 2 ? 1 : d == 8 ? -1 : 0)
    return force_movement if $game_map.terrain_tag(new_x, new_y) == $ABS.PASS_TAG and no_one?
    m = @move_direction
    move_down if m == 2
    move_left if m == 4
    move_right if m == 6
    move_up if m == 8
    #Stop if it came to range
    return @stop = true if @step >= @range
    #Increase step
    @step += 1
  end
  #--------------------------------------------------------------------------
  # * No One
  #-------------------------------------------------------------------------
  def no_one?
    #Get All Events
    objects = $game_map.events
    objects[0] = $game_player
    # Get new coordinates
    d = @move_direction
    new_x = x + (d == 6 ? 1 : d == 4 ? -1 : 0)
    new_y = y + (d == 2 ? 1 : d == 8 ? -1 : 0)
    #Get all pos
    for o in objects
      next if o == nil
      return false if o.x == @x and o.y == @y
    end
    #Return False if no one was found
    return true
  end
end
#============================================================================
# * Game Ranged Explode
#============================================================================
class Game_Ranged_Explode < Range_Base
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(parent, actor, skill)
    super(parent,actor,skill)
    @range_skill = $ABS.RANGE_EXPLODE[skill.id]
    @range = @range_skill[0]
    @opacity = 10 if @range == 1
    @move_speed = @range_skill[1]
    @character_name = ''#@range_skill[2]
    @skill = skill
    @explosive = true
  end
  #--------------------------------------------------------------------------
  # * Check Event Trigger Touch(x,y)
  #--------------------------------------------------------------------------
  def check_event_trigger_touch(x, y)
    return
  end
  #--------------------------------------------------------------------------
  # * Update
  #--------------------------------------------------------------------------
  def update
    super
    #Return if moving
    return if moving?
    # Get new coordinates
    d = @move_direction
    new_x = x + (d == 6 ? 1 : d == 4 ? -1 : 0)
    new_y = y + (d == 2 ? 1 : d == 8 ? -1 : 0)
    return force_movement if $game_map.terrain_tag(new_x, new_y) == $ABS.PASS_TAG and no_one?
    #Stop if can't move
    return blow if !passable?(@x, @y, @move_direction)
    m = @move_direction
    move_down if m == 2
    move_left if m == 4
    move_right if m == 6
    move_up if m == 8
    #Stop if it came to range
    return blow if @step >= @range
    #Increase step
    @step += 1
  end
  #--------------------------------------------------------------------------
  # * In Range?(Element, Object, Range) - Near Fantastica
  #--------------------------------------------------------------------------
  def in_range?(element, object, range)
    x = (element.x - object.x) * (element.x - object.x)
    y = (element.y - object.y) * (element.y - object.y)
    r = x + y
    return true if r <= (range * range)
    return false
  end
  #--------------------------------------------------------------------------
  # * Get ALL Range(Element, Range)
  #--------------------------------------------------------------------------
  def get_all_range(element, range)
    objects = []
    for e in $ABS.enemies.values
      objects.push(e) if in_range?(element, e.event, range)
    end
    objects.push($game_player) if in_range?(element, $game_player, range)
    return objects
  end
  #--------------------------------------------------------------------------
  # * Blow
  #--------------------------------------------------------------------------
  def blow
    #Stop
    @stop = true
    #Play Animation
    #Show animation on event
    self.animation_id = @skill.animation2_id
    @showing_ani = true
    #Get Everyone in Range of the Explosive Skill
    objects = get_all_range(self, @range_skill[3])
    #Hit Everyone
    hit_player if objects.include?($game_player)
    #Hit Enemies
    for e in objects
      next if e == nil
      next if e == $game_player
      #Hit
      hit_event(e.id)
    end
  end
  #--------------------------------------------------------------------------
  # * Hit Player
  #--------------------------------------------------------------------------
  def hit_player
    @stop = true
    #Get Actor
    actor = $game_party.actors[0]
    #Get Enemy
    enemy = @actor
    #Attack Actor
    actor.effect_skill(enemy, @skill)
    #Check if enemy is dead
    $ABS.enemy_dead?(actor, enemy)
  end  
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def hit_event(id)
    @stop = true
    #Get enemy
    actor = $ABS.enemies[id]
    #Return if actor has NIL value
    return if actor == nil
    #If the parent is player
    if @parent.is_a?(Game_Player)
      #Get enemy
      enemy = $game_party.actors[0]
      #Attack It's enemy
      actor.effect_skill(enemy, @skill)
      return if $ABS.enemy_dead?(actor, enemy)
      return if !actor.hate_group.include?(0)
      #Put enemy in battle
      actor.in_battle = true
      actor.attacking = $game_player
      $ABS.setup_movement(actor)
      return
    end
    #Get enemy
    enemy = $ABS.enemies[@parent.id]
    #Attack It's enemy
    actor.effect_skill(enemy, @skill)
    #Show animation on event
    actor.event.animation_id = @skill.animation2_id if actor.damage != "Miss" and actor.damage != 0
    #return if enemy is dead
    return if $ABS.enemy_dead?(actor, enemy)
    return if !actor.hate_group.include?(enemy.enemy_id)
    actor.in_battle = true
    actor.attacking = enemy
    $ABS.setup_movement(actor)
  end
end
#============================================================================
# * Game Ranged Skill
#============================================================================
class Game_Ranged_Skill < Range_Base
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(parent, actor, skill)
    super(parent,actor,skill)
    @range_skill = $ABS.RANGE_SKILLS[skill.id]
    @range = @range_skill[0]
    @opacity = 10 if @range == 1
    @move_speed = @range_skill[1]
    @character_name = ''#@range_skill[2]
    @skill = skill
  end
  #--------------------------------------------------------------------------
  # * Check Event Trigger Touch(x,y)
  #--------------------------------------------------------------------------
  def check_event_trigger_touch(x, y)
    return if @stop
    hit_player if x == $game_player.x and y == $game_player.y
    for event in $game_map.events.values
      if event.x == x and event.y == y
        if event.character_name == ""
          froce_movement
        else
          hit_event(event.id)
        end
      end
    end
  end
  #--------------------------------------------------------------------------
  # * Hit Player
  #--------------------------------------------------------------------------
  def hit_player
    @stop = true
    #Get Actor
    actor = $game_party.actors[0]
    #Get Enemy
    enemy = @actor
    #Attack Actor
    actor.effect_skill(enemy, @skill)
    #Show animation on player
    $game_player.animation_id = @skill.animation2_id if actor.damage != "Miss" and actor.damage != 0
    #Check if enemy is dead
    $ABS.enemy_dead?(actor, enemy)
  end  
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def hit_event(id)
    @stop = true
    #Get enemy
    actor = $ABS.enemies[id]
    #Return if actor has NIL value
    return if actor == nil
    #If the parent is player
    if @parent.is_a?(Game_Player)
      #Get enemy
      enemy = $game_party.actors[0]
      #Attack It's enemy
      actor.effect_skill(enemy, @skill)
      #Show animation on event
      actor.event.animation_id = @skill.animation2_id if actor.damage != "Miss" and actor.damage != 0
      return if $ABS.enemy_dead?(actor, enemy)
      return if !actor.hate_group.include?(0)
      #Put enemy in battle
      actor.in_battle = true
      actor.attacking = $game_player
      $ABS.setup_movement(actor)
      return
    end
    #Get enemy
    enemy = $ABS.enemies[@parent.id]
    #Attack It's enemy
    actor.effect_skill(enemy, @skill)
    #Show animation on event
    actor.event.animation_id = @skill.animation2_id if actor.damage != "Miss" and actor.damage != 0
    #return if enemy is dead
    return if $ABS.enemy_dead?(actor, enemy)
    return if !actor.hate_group.include?(enemy.enemy_id)
    actor.in_battle = true
    actor.attacking = enemy
    $ABS.setup_movement(actor)
  end
end
#============================================================================
# * Game Ranged Weapons
#============================================================================
class Game_Ranged_Weapon < Range_Base
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(parent, actor, attack)
    super(parent,actor,attack)
    @range_wepaon = $ABS.RANGE_WEAPONS[attack]
    @character_name = '' #@range_wepaon[0]
    @move_speed = @range_wepaon[1]
    @range = @range_wepaon[4]
  end
  #--------------------------------------------------------------------------
  # * Check Event Trigger Touch(x,y)
  #--------------------------------------------------------------------------
  def check_event_trigger_touch(x, y)
    return if @stop
    hit_player if x == $game_player.x and y == $game_player.y
    for event in $game_map.events.values
      next if event.x != x or event.y != y
      if event.character_name == ""
        froce_movement
      else
        hit_event(event.id)
      end
    end
  end
  #--------------------------------------------------------------------------
  # * Hit Player
  #--------------------------------------------------------------------------
  def hit_player
    @stop = true
    #Get Actor
    actor = $game_party.actors[0]
    #Get Enemy
    enemy = @actor
    #Attack Actor
    actor.attack_effect(enemy)
    #Show animation on player
    $game_player.animation_id = @range_wepaon[2] if actor.damage != "Miss" and actor.damage != 0
    #Check if enemy is dead
    $ABS.enemy_dead?(actor, enemy)
  end  
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def hit_event(id)
    @stop = true
    #Get enemy
    actor = $ABS.enemies[id]
    #Return if actor has NIL value
    return if actor == nil
    #If the parent is player
    if @parent.is_a?(Game_Player)
      #Get enemy
      enemy = $game_party.actors[0]
      #Attack It's enemy
      actor.attack_effect(enemy)
      #Show animation on event
      actor.event.animation_id = @range_wepaon[2] if actor.damage != "Miss" and actor.damage != 0
      return if $ABS.enemy_dead?(actor, enemy)
      return if !actor.hate_group.include?(0)
      #Put enemy in battle
      actor.in_battle = true
      actor.attacking = $game_player
      $ABS.setup_movement(actor)
      return
    end
    #Get enemy
    enemy = $ABS.enemies[@parent.id]
    #Attack It's enemy
    actor.attack_effect(enemy)
    #Show animation on event
    actor.event.animation_id = @skill.animation2_id if actor.damage != "Miss" and actor.damage != 0
    #return if enemy is dead
    return if $ABS.enemy_dead?(actor, enemy)
    return if !actor.hate_group.include?(enemy.enemy_id)
    actor.in_battle = true
    actor.attacking = enemy
    $ABS.setup_movement(actor)
  end
end
#============================================================================
# *  Game Event  - Near Fantastica
#============================================================================
class Game_Event < Game_Character
  #--------------------------------------------------------------------------
  # * Alias
  #--------------------------------------------------------------------------
  alias mrmo_abs_game_event_refresh_set_page refresh_set_page
  #--------------------------------------------------------------------------
  # * Event Name
  #--------------------------------------------------------------------------
  def name
    return @event.name
  end
  #--------------------------------------------------------------------------
  # * Event ID
  #--------------------------------------------------------------------------
  def id
    return @id
  end
  #--------------------------------------------------------------------------
  # * Refreshes Page
  #--------------------------------------------------------------------------
  def refresh_set_page
    mrmo_abs_game_event_refresh_set_page
    $ABS.refresh(self, @list, @character_name)
  end
end
#============================================================================
# * Scene Load
#============================================================================
class Scene_Load < Scene_File
  #--------------------------------------------------------------------------
  alias mrmo_abs_scene_load_read_data read_data
  #--------------------------------------------------------------------------
  def read_data(file)
    mrmo_abs_scene_load_read_data(file)
    $ABS = Marshal.load(file)
  end
end
#============================================================================
# * Scene Save
#============================================================================
class Scene_Save < Scene_File
  #--------------------------------------------------------------------------
  alias mrmo_abs_scene_save_write_data write_data
  #--------------------------------------------------------------------------
  def write_data(file)
    mrmo_abs_scene_save_write_data(file)
    Marshal.dump($ABS, file)
  end
end
#============================================================================
# * Scene Title
#============================================================================
class Scene_Title
  #--------------------------------------------------------------------------
  alias mrmo_abs_scene_title_cng command_new_game
  #--------------------------------------------------------------------------
  def command_new_game
    $ABS = MrMo_ABS.new
    $quest = []
    mrmo_abs_scene_title_cng
  end
end
#============================================================================
# * Scene Map
#============================================================================
class Scene_Map
  #--------------------------------------------------------------------------
  alias mrmo_abs_scene_map_update update
  #--------------------------------------------------------------------------
  def update
    $ABS.update
    mrmo_abs_scene_map_update
  end
end
#============================================================================
# * Scene Map
#============================================================================
class Game_Player
  #--------------------------------------------------------------------------
  alias mrmo_abs_game_player_initialize initialize
  #--------------------------------------------------------------------------
  attr_accessor :event_id
  attr_accessor :event
  attr_accessor :actor
  attr_accessor :enemy_id
  def initialize
    super
    @event_id = 0
    @event = self
    @enemy_id = 0
    @actor = $game_party.actors[0]
    mrmo_abs_game_player_initialize
  end
end
#============================================================================
# * RPG::Sprite
#============================================================================
module RPG
  class Sprite < ::Sprite
    def initialize(viewport = nil)
      super(viewport)
      @_whiten_duration = 0
      @_appear_duration = 0
      @_escape_duration = 0
      @_collapse_duration = 0
      @_damage_duration = 0
      @_animation_duration = 0
      @_blink = false
      @stop_animation = true
    end
    def update_animation
      if @_animation_duration > 0
        frame_index = @_animation.frame_max - @_animation_duration
        cell_data = @_animation.frames[frame_index].cell_data
        position = @_animation.position
        animation_set_sprites(@_animation_sprites, cell_data, position)
        for timing in @_animation.timings
          if timing.frame == frame_index
            animation_process_timing(timing, @_animation_hit)
          end
        end
      else
        @stop_animation = true
        dispose_animation
      end
    end
    def animation(animation, hit)
      @stop_animation = false
      dispose_animation
      @_animation = animation
      return if @_animation == nil
      @_animation_hit = hit
      @_animation_duration = @_animation.frame_max
      animation_name = @_animation.animation_name
      animation_hue = @_animation.animation_hue
      bitmap = RPG::Cache.animation(animation_name, animation_hue)
      if @@_reference_count.include?(bitmap)
        @@_reference_count[bitmap] += 1
      else
        @@_reference_count[bitmap] = 1
      end
      @_animation_sprites = []
      if @_animation.position != 3 or not @@_animations.include?(animation)
        for i in 0..15
          sprite = ::Sprite.new(self.viewport)
          sprite.bitmap = bitmap
          sprite.visible = false
          @_animation_sprites.push(sprite)
        end
        unless @@_animations.include?(animation)
          @@_animations.push(animation)
        end
      end
      update_animation
    end
    def stop_animation?
      return @stop_animation 
    end
  end
end
#==============================================================================
# ** Spriteset_Map
#------------------------------------------------------------------------------
#  This class brings together map screen sprites, tilemaps, etc.
#  It's used within the Scene_Map class.
#==============================================================================
class Spriteset_Map
  #--------------------------------------------------------------------------
  alias mrmo_spriteset_map_init_characters init_characters
  alias mrmo_spriteset_map_update_character_sprites update_character_sprites
  alias mrmo_spriteset_map_dispose dispose
  #--------------------------------------------------------------------------
  # * Character Sprite Initialization
  #--------------------------------------------------------------------------
  def init_characters
    mrmo_spriteset_map_init_characters
    # Make character sprites
    @ranged_sprites = []
    for range in $ABS.range
      #Skip NIL Values
      next if range == nil and !range.draw
      sprite = Sprite_Character.new(@viewport1, range)
      @ranged_sprites.push(sprite)
    end
  end
  #--------------------------------------------------------------------------
  # * Dispose
  #--------------------------------------------------------------------------
  def dispose
    # Update ranged sprites
    for range in @ranged_sprites
      #Skip NIL Values
      next if range == nil
      range.dispose
    end
    mrmo_spriteset_map_dispose
  end
  #--------------------------------------------------------------------------
  # * Update Character Sprites
  #--------------------------------------------------------------------------
  def update_character_sprites
    mrmo_spriteset_map_update_character_sprites
    # Update ranged sprites
    for range in @ranged_sprites
      #Skip NIL Values
      next if range == nil
      range.update
      #If its stop
      if range.character.stop and range.stop_animation?
        @ranged_sprites.delete(range)
        range.dispose
        $ABS.range.delete(range.character)
      elsif range.character.stop 
        range.character.character_name = ""
      end
    end
    # Draw Sprite
    for range in $ABS.range
      #Skip NIL Values
      next if range == nil and !range.draw
      #If its draw
      sprite = Sprite_Character.new(@viewport1, range)
      @ranged_sprites.push(sprite)
      range.draw = false
    end
    # Damage Display
    #Get all enemies and player
    for sprite in @character_sprites
      #Skip NIL Value or No damage display
      next if sprite == nil or !$ABS.damage_display
      #Skip Events
      id = sprite.character.id
      next if $ABS.enemies[id] == nil and !sprite.character.is_a?(Game_Player)
      #Skip if no demage or dead;
      if !sprite.character.is_a?(Game_Player)
        #Skip no demage or dead
        next if $ABS.enemies[id].dead? or $ABS.enemies[id].damage == nil
        #Display damage
        sprite.damage($ABS.enemies[id].damage, $ABS.enemies[id].critical)
        #Make Damage nil
        $ABS.enemies[id].damage = nil
      else
        a = $game_party.actors[0]
        #Next if player is dead or demage is NIL
        next if a.dead? or a.damage == nil
        #Display damage
        sprite.damage(a.damage, a.critical)
        #Make Damage nil
        a.damage = nil
      end
    end
  end
end
#==============================================================================
# ** Game_Battler (part 3)
#------------------------------------------------------------------------------
#  This class deals with battlers. It's used as a superclass for the Game_Actor
#  and Game_Enemy classes.
#==============================================================================
class Game_Battler
  #--------------------------------------------------------------------------
  # * Determine Usable Skills
  #     skill_id : skill ID
  #--------------------------------------------------------------------------
  def can_use_skill?(skill)
    # If there's not enough SP, the skill cannot be used.
    return false if skill.sp_cost > self.sp
    # Unusable if incapacitated
    return false if dead?
    # If silent, only physical skills can be used
    return false if skill.atk_f == 0 and self.restriction == 1
    # Get usable time
    occasion = skill.occasion
    case occasion
    when 0..1
      return true
    when 2..3
      return false
    end
  end
  #--------------------------------------------------------------------------
  # * Apply Skill Effects
  #     user  : the one using skills (battler)
  #     skill : skill
  #--------------------------------------------------------------------------
  def effect_skill(user, skill)
    # Clear critical flag
    self.critical = false
    # If skill scope is for ally with 1 or more HP, and your own HP = 0,
    # or skill scope is for ally with 0, and your own HP = 1 or more
    if ((skill.scope == 3 or skill.scope == 4) and self.hp == 0) or
       ((skill.scope == 5 or skill.scope == 6) and self.hp >= 1)
      # End Method
      return false
    end
    # Clear effective flag
    effective = false
    # Set effective flag if common ID is effective
    effective |= skill.common_event_id > 0
    # First hit detection
    hit = skill.hit
    if skill.atk_f > 0
      hit *= user.hit / 100
    end
    hit_result = (rand(100) < hit)
    # Set effective flag if skill is uncertain
    effective |= hit < 100
    # If hit occurs
    if hit_result == true
      # Calculate power
      power = skill.power + user.atk * skill.atk_f / 100
      if power > 0
        power -= self.pdef * skill.pdef_f / 200
        power -= self.mdef * skill.mdef_f / 200
        power = [power, 0].max
      end
      # Calculate rate
      rate = 20
      rate += (user.str * skill.str_f / 100)
      rate += (user.dex * skill.dex_f / 100)
      rate += (user.agi * skill.agi_f / 100)
      rate += (user.int * skill.int_f / 100)
      # Calculate basic damage
      self.damage = power * rate / 20
      # Element correction
      self.damage *= elements_correct(skill.element_set)
      self.damage /= 100
      # If damage value is strictly positive
      if self.damage > 0
        # Guard correction
        if self.guarding?
          self.damage /= 2
        end
      end
      # Dispersion
      if skill.variance > 0 and self.damage.abs > 0
        amp = [self.damage.abs * skill.variance / 100, 1].max
        self.damage += rand(amp+1) + rand(amp+1) - amp
      end
      # Second hit detection
      eva = 8 * self.agi / user.dex + self.eva
      hit = self.damage < 0 ? 100 : 100 - eva * skill.eva_f / 100
      hit = self.cant_evade? ? 100 : hit
      hit_result = (rand(100) < hit)
      # Set effective flag if skill is uncertain
      effective |= hit < 100
    end
    # If hit occurs
    if hit_result == true
      # If physical attack has power other than 0
      if skill.power != 0 and skill.atk_f > 0
        # State Removed by Shock
        remove_states_shock
        # Set to effective flag
        effective = true
      end
      # Substract damage from HP
      last_hp = self.hp
      self.hp -= self.damage
      effective |= self.hp != last_hp
      # State change
      @state_changed = false
      effective |= states_plus(skill.plus_state_set)
      effective |= states_minus(skill.minus_state_set)
      # If power is 0
      if skill.power == 0
        # Set damage to an empty string
        self.damage = ""
        # If state is unchanged
        unless @state_changed
          # Set damage to "Miss"
          self.damage = "Miss"
        end
      end
    # If miss occurs
    else
      # Set damage to "Miss"
      self.damage = "Miss"
    end
    # End Method
    return effective
  end
end
#==============================================================================
# ** Game_Character (part 1)
#------------------------------------------------------------------------------
#  This class deals with characters. It's used as a superclass for the
#  Game_Player and Game_Event classes.
#==============================================================================
class Game_Character
  attr_accessor :move_type
  attr_accessor :move_speed
  attr_accessor :move_frequency
  attr_accessor :character_name
  #--------------------------------------------------------------------------
  # * Set Animation
  #--------------------------------------------------------------------------
  def set_animate(name)
    return if @animating
    @frame = 4
    @old_char = @character_name
    @character_name = name
    @animating = true
    @anim_wait = 20
    @pattern = 0
    @direction_fix = true
  end
  #--------------------------------------------------------------------------
  alias mrmo_abs_game_character_update update
  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update
    return animate_pose if @animating
    mrmo_abs_game_character_update
  end
  #--------------------------------------------------------------------------
  # * Frame Update Pose
  #--------------------------------------------------------------------------
  def animate_pose
    if @anim_wait >= 4
      @pattern = (@pattern + 1) % 4
      @frame -= 1
      @anim_wait = 0
    end
    @anim_wait += 1 if @anim_wait < 18 - @move_speed * 2
    if @frame == 0
      @animating = false
      @character_name = @old_char
      @direction_fix = false
      return
    end
    update_jump if jumping?
  end
  #--------------------------------------------------------------------------
  # * Move toward B
  #--------------------------------------------------------------------------
  def move_to(b)
    # Get difference in player coordinates
    sx = @x - b.x
    sy = @y - b.y
    # If coordinates are equal
    if sx == 0 and sy == 0
      return
    end
    # Get absolute value of difference
    abs_sx = sx.abs
    abs_sy = sy.abs
    # If horizontal and vertical distances are equal
    if abs_sx == abs_sy
      # Increase one of them randomly by 1
      rand(2) == 0 ? abs_sx += 1 : abs_sy += 1
    end
    # If horizontal distance is longer
    if abs_sx > abs_sy
      # Move towards player, prioritize left and right directions
      sx > 0 ? move_left : move_right
      if not moving? and sy != 0
        sy > 0 ? move_up : move_down
      end
    # If vertical distance is longer
    else
      # Move towards player, prioritize up and down directions
      sy > 0 ? move_up : move_down
      if not moving? and sx != 0
        sx > 0 ? move_left : move_right
      end
    end
    turn_to(b)
  end
  #--------------------------------------------------------------------------
  # * Turn Towards B
  #--------------------------------------------------------------------------
  def turn_to(b)
    # Get difference in player coordinates
    sx = @x - b.x
    sy = @y - b.y
    # If coordinates are equal
    if sx == 0 and sy == 0
      return
    end
    # If horizontal distance is longer
    if sx.abs > sy.abs
      # Turn to the right or left towards player
      sx > 0 ? turn_left : turn_right
    # If vertical distance is longer
    else
      # Turn up or down towards player
      sy > 0 ? turn_up : turn_down
    end
  end
end
#==============================================================================
# ** Game_Party
#------------------------------------------------------------------------------
#  This class handles the party. It includes information on amount of gold 
#  and items. Refer to "$game_party" for the instance of this class.
#==============================================================================
class Game_Party
  #--------------------------------------------------------------------------
  alias mrmo_abs_game_party_setup_starting_members setup_starting_members
  #--------------------------------------------------------------------------
  # * Initial Party Setup
  #--------------------------------------------------------------------------
  def setup_starting_members
    mrmo_abs_game_party_setup_starting_members
    $game_player.actor = $game_party.actors[0]
  end
end
#============================================================================
# * ABS Enemy
#============================================================================
class ABS_Enemy < Game_Battler
  #--------------------------------------------------------------------------
  attr_accessor :event_id
  attr_accessor :enemy_id
  attr_accessor :behavior
  attr_accessor :see_range
  attr_accessor :hear_range
  attr_accessor :aggressiveness
  attr_accessor :trigger   
  attr_accessor :hate_points
  attr_accessor :hate_group
  attr_accessor :closest_enemy
  attr_accessor :in_battle
  attr_accessor :ranged
  attr_accessor :event
  attr_accessor :attacking
  attr_accessor :temp_move_type
  attr_accessor :temp_speed
  attr_accessor :temp_frequency
  attr_accessor :actor
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(enemy_id)
    super()
    @event_id= 0
    @see_range = 0
    @hear_range = 0
    @aggressiveness = 1
    @trigger = []
    @enemy_id = enemy_id
    @in_battle = false
    @hp = maxhp
    @sp = maxsp
    @closest_enemy = false
    @hate_points = []
    @ranged = nil
    @hate_group = []
    @event = nil
    @attacking = nil
    @temp_move_type = 0 
    @temp_speed = 0
    @temp_frequency = 0 
    @actor = self
  end
  #--------------------------------------------------------------------------
  # * Get Enemy ID
  #--------------------------------------------------------------------------
  def id
    return @enemy_id
  end
  #--------------------------------------------------------------------------
  # * Get Index
  #--------------------------------------------------------------------------
  def index
    return @member_index
  end
  #--------------------------------------------------------------------------
  # * Get Name
  #--------------------------------------------------------------------------
  def name
    return $data_enemies[@enemy_id].name
  end
  #--------------------------------------------------------------------------
  # * Get Basic Maximum HP
  #--------------------------------------------------------------------------
  def base_maxhp
    return $data_enemies[@enemy_id].maxhp
  end
  #--------------------------------------------------------------------------
  # * Get Basic Maximum SP
  #--------------------------------------------------------------------------
  def base_maxsp
    return $data_enemies[@enemy_id].maxsp
  end
  #--------------------------------------------------------------------------
  # * Get Basic Strength
  #--------------------------------------------------------------------------
  def base_str
    return $data_enemies[@enemy_id].str
  end
  #--------------------------------------------------------------------------
  # * Get Basic Dexterity
  #--------------------------------------------------------------------------
  def base_dex
    return $data_enemies[@enemy_id].dex
  end
  #--------------------------------------------------------------------------
  # * Get Basic Agility
  #--------------------------------------------------------------------------
  def base_agi
    return $data_enemies[@enemy_id].agi
  end
  #--------------------------------------------------------------------------
  # * Get Basic Intelligence
  #--------------------------------------------------------------------------
  def base_int
    return $data_enemies[@enemy_id].int
  end
  #--------------------------------------------------------------------------
  # * Get Basic Attack Power
  #--------------------------------------------------------------------------
  def base_atk
    return $data_enemies[@enemy_id].atk
  end
  #--------------------------------------------------------------------------
  # * Get Basic Physical Defense
  #--------------------------------------------------------------------------
  def base_pdef
    return $data_enemies[@enemy_id].pdef
  end
  #--------------------------------------------------------------------------
  # * Get Basic Magic Defense
  #--------------------------------------------------------------------------
  def base_mdef
    return $data_enemies[@enemy_id].mdef
  end
  #--------------------------------------------------------------------------
  # * Get Basic Evasion
  #--------------------------------------------------------------------------
  def base_eva
    return $data_enemies[@enemy_id].eva
  end
  #--------------------------------------------------------------------------
  # * Get Offensive Animation ID for Normal Attack
  #--------------------------------------------------------------------------
  def animation1_id
    return $data_enemies[@enemy_id].animation1_id
  end
  #--------------------------------------------------------------------------
  # * Get Target Animation ID for Normal Attack
  #--------------------------------------------------------------------------
  def animation2_id
    return $data_enemies[@enemy_id].animation2_id
  end
  #--------------------------------------------------------------------------
  # * Get Element Revision Value
  #     element_id : Element ID
  #--------------------------------------------------------------------------
  def element_rate(element_id)
    # Get a numerical value corresponding to element effectiveness
    table = [0,200,150,100,50,0,-100]
    result = table[$data_enemies[@enemy_id].element_ranks[element_id]]
    # If protected by state, this element is reduced by half
    for i in @states
      if $data_states[i].guard_element_set.include?(element_id)
        result /= 2
      end
    end
    # End Method
    return result
  end
  #--------------------------------------------------------------------------
  # * Get State Effectiveness
  #--------------------------------------------------------------------------
  def state_ranks
    return $data_enemies[@enemy_id].state_ranks
  end
  #--------------------------------------------------------------------------
  # * Determine State Guard
  #     state_id : state ID
  #--------------------------------------------------------------------------
  def state_guard?(state_id)
    return false
  end
  #--------------------------------------------------------------------------
  # * Get Normal Attack Element
  #--------------------------------------------------------------------------
  def element_set
    return []
  end
  #--------------------------------------------------------------------------
  # * Get Normal Attack State Change (+)
  #--------------------------------------------------------------------------
  def plus_state_set
    return []
  end
  #--------------------------------------------------------------------------
  # * Get Normal Attack State Change (-)
  #--------------------------------------------------------------------------
  def minus_state_set
    return []
  end
  #--------------------------------------------------------------------------
  # * Aquire Actions
  #--------------------------------------------------------------------------
  def actions
    return $data_enemies[@enemy_id].actions
  end
  #--------------------------------------------------------------------------
  # * Get EXP
  #--------------------------------------------------------------------------
  def exp
    return $data_enemies[@enemy_id].exp
  end
  #--------------------------------------------------------------------------
  # * Get Gold
  #--------------------------------------------------------------------------
  def gold
    return $data_enemies[@enemy_id].gold
  end
  #--------------------------------------------------------------------------
  # * Get Item ID
  #--------------------------------------------------------------------------
  def item_id
    return $data_enemies[@enemy_id].item_id
  end
  #--------------------------------------------------------------------------
  # * Get Weapon ID
  #--------------------------------------------------------------------------
  def weapon_id
    return $data_enemies[@enemy_id].weapon_id
  end
  #--------------------------------------------------------------------------
  # * Get Armor ID
  #--------------------------------------------------------------------------
  def armor_id
    return $data_enemies[@enemy_id].armor_id
  end
  #--------------------------------------------------------------------------
  # * Get Treasure Appearance Probability
  #--------------------------------------------------------------------------
  def treasure_prob
    return $data_enemies[@enemy_id].treasure_prob
  end
end
#==============================================================================
# ** Scene_Skill
#------------------------------------------------------------------------------
#  This class performs skill screen processing.
#==============================================================================
class Scene_Skill
  #--------------------------------------------------------------------------
  alias mrmo_moabs_scene_skill_main main
  alias mrmo_moabs_scene_skill_update update
  alias mrmo_moabs_scene_skill_update_skill update_skill
  #--------------------------------------------------------------------------
  # * Main Processing
  #--------------------------------------------------------------------------
  def main
    @shk_window = Window_Command.new(250, [$ABS.HOTKEY_SAY.to_s])
    @shk_window.visible = false
    @shk_window.active = false
    @shk_window.x = 200
    @shk_window.y = 250
    @shk_window.z = 1500
    mrmo_moabs_scene_skill_main  
    @shk_window.dispose
  end
  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update 
    @shk_window.update if @shk_window.active
    mrmo_moabs_scene_skill_update
    return update_shk if @shk_window.active
  end
  #--------------------------------------------------------------------------
  # * Frame Update (if skill window is active)
  #--------------------------------------------------------------------------
  def update_skill
    mrmo_moabs_scene_skill_update_skill
    #Get all the keys
    for key in $ABS.skill_keys.keys
      #Check is the the key is pressed
      next if !Input.trigger?(key)
      #Play decision
      $game_system.se_play($data_system.decision_se)
      #Record Skill
      $ABS.skill_keys[key] = @skill_window.skill.id 
      @skill_window.active = false
      @shk_window.active = @shk_window.visible = true
    end
  end
  #--------------------------------------------------------------------------
  # * Frame Update Skill Hot Key
  #--------------------------------------------------------------------------
  def update_shk
    #Return if Enter isn't pressed
    return if !Input.trigger?(Input::C)
    #Play decision
    $game_system.se_play($data_system.decision_se)
    @shk_window.active = @shk_window.visible = false
    @skill_window.active = true
    $scene = Scene_Skill.new(@actor_index)
  end
end

#--------------------------------------------------------------------------
# * SDK End
#--------------------------------------------------------------------------
end